# -*- coding: utf-8 -*-
"""Rosalind_Functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LHKfEQP2rPFZUPIRsXKPxCiaNFABeFvT
"""



"""DNA

Problem
A string is simply an ordered collection of symbols selected from some alphabet and formed into a word; the length of a string is the number of symbols that it contains.

An example of a length 21 DNA string (whose alphabet contains the symbols 'A', 'C', 'G', and 'T') is "ATGCTTCAGAAAGGTCTTACG."

Given: A DNA string s
 of length at most 1000 nt.

Return: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s.
"""

#This script will be used to count the number of nucleotides in an input DNA sequence
#AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC

import pandas as pd
import numpy as np

#The .count function will return us the number of times each particular nucleotide appears
def count_nucleotides(sequence):
  A_count = sequence.count("A")
  C_count = sequence.count("C")
  G_count = sequence.count("G")
  T_count = sequence.count("T")

  return f"This is the number of times A appears: {A_count}, This is the numer of times C appears: {C_count}, This is the number of times G appears: {G_count}, This is the number of times T appears: {T_count}"

count_nucleotides("AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC")

"""RNA

Problem
An RNA string is a string formed from the alphabet containing 'A', 'C', 'G', and 'U'.

Given a DNA string t
 corresponding to a coding strand, its transcribed RNA string u
 is formed by replacing all occurrences of 'T' in t
 with 'U' in u
.

Given: A DNA string t
 having length at most 1000 nt.

Return: The transcribed RNA string of t.
"""

#GATGGAACTTGACTACGTAAATT
#The following code intakes a DNA sequence as an input and will return its complementary RNA sequence

def DNA_to_RNA(sequence):
  RNA_Dictionary = {"A":"A", "G":"G", "C":"C", "T":"U"}
  return "".join(RNA_Dictionary[nucleotide] for nucleotide in sequence) #start with an empty string and for every nucleotide in our input sequence match with its value from our RNA dictionary and join that into our empty string

DNA_to_RNA ("GATGGAACTTGACTACGTAAATT")

"""REVC

In DNA strings, symbols 'A' and 'T' are complements of each other, as are 'C' and 'G'.

The reverse complement of a DNA string s
 is the string sc
 formed by reversing the symbols of s
, then taking the complement of each symbol (e.g., the reverse complement of "GTCA" is "TGAC").

Given: A DNA string s
 of length at most 1000 bp.

Return: The reverse complement sc
 of s.
"""

#Start with a sequence of DNA, flip the sequence, and find the complement of each nucleotide
#The way we'll match each nucleotide to its complement is by creating a dictionary
dna_dict = {'A':'T', 'T':'A', 'G':'C', 'C':'G'}
def reverse_complement(dna):
  reverse= dna[::-1]
  reverse_complement = ''
  for nucleotide in reverse:
    reverse_complement += dna_dict[nucleotide]
  return reverse_complement

reverse_complement('AAAACCCGGT')

"""GC

Problem
The GC-content of a DNA string is given by the percentage of symbols in the string that are 'C' or 'G'. For example, the GC-content of "AGCTATAG" is 37.5%. Note that the reverse complement of any DNA string has the same GC-content.

DNA strings must be labeled when they are consolidated into a database. A commonly used method of string labeling is called FASTA format. In this format, the string is introduced by a line that begins with '>', followed by some labeling information. Subsequent lines contain the string itself; the first line to begin with '>' indicates the label of the next string.

In Rosalind's implementation, a string in FASTA format will be labeled by the ID "Rosalind_xxxx", where "xxxx" denotes a four-digit code between 0000 and 9999.

Given: At most 10 DNA strings in FASTA format (of length at most 1 kbp each).

Return: The ID of the string having the highest GC-content, followed by the GC-content of that string. Rosalind allows for a default error of 0.001 in all decimal answers unless otherwise stated; please see the note on absolute error below.
"""

#In this function our input is going to be a list of DNA sequences, 10 max. And we can check that by doing length(list). After checking we'll do a for loop and go through each sequence in our list and compute the GC content for each string. We'll return the highest GC percentage.

def GC_content(list):
  if len(list) > 10:
    return 'there are more than 10 sequences'
  else :
    for sequence in list:
      gc_values_list = []

      G_count= sequence.count('G')
      C_count= sequence.count('C')
      GC_content= ((G_count+C_count)/len(sequence)) * 100

      gc_values_list.append(GC_content)

      max_index = gc_values_list.index(max(gc_values_list))

      dna_max_gc = list[max_index]
    return max(gc_values_list), dna_max_gc

test_list=['CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCCTCCCACTAATAATTCTGAGG',
           'CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCTATATCCATTTGTCAGCAGACACGC']

GC_content(test_list)

"""HAMM

Problem

Figure 2. The Hamming distance between these two strings is 7. Mismatched symbols are colored red.
Given two strings s
 and t
 of equal length, the Hamming distance between s
 and t
, denoted dH(s,t)
, is the number of corresponding symbols that differ in s
 and t
. See Figure 2.

Given: Two DNA strings s
 and t
 of equal length (not exceeding 1 kbp).

Return: The Hamming distance dH(s,t).
"""

#First we check to make sure our two sequences are equal in length. Once that is true, we will count the number of times that there is a mismatch between the two sequences. We will do that by using a for loop and go through each nucleotide of our first sequence and make sure it matches at the same index at the second sequence.

seq_test1 = "atgatg"
seq_test2 ="ttgatg"

def hamming_distance(seq1, seq2):
  if len(seq1) != len(seq2):
    return "Sequences are not the same length"
  else:
    count = 0
    for position in range(len(seq1)):
      if seq1[position] != seq2[position]:
        count += 1
    return f"Hamming distance (number of mismatches): {count}"

hamming_distance('GAGCCTACTAACGGGAT','CATCGTAATGACGGCCT')

PROT
Problem
The 20 commonly occurring amino acids are abbreviated by using 20 letters from the English alphabet (all letters except for B, J, O, U, X, and Z). Protein strings are constructed from these 20 symbols. Henceforth, the term genetic string will incorporate protein strings along with DNA strings and RNA strings.

The RNA codon table dictates the details regarding the encoding of specific codons into the amino acid alphabet.

Given: An RNA string s
 corresponding to a strand of mRNA (of length at most 10 kbp).

Return: The protein string encoded by s.

#We will need to go through every three RNA nucleotides and find the amino acid it matches with, we will add that amino acid to our final string. To do this, we need to have a dictionary where codon matches to amino acid. First thing we need to do is find our start codon, AUG, and start from there. From then on, we will look at every three codons and match with its corresponding amino acid. If one of the codons is a stop codon then we quit.

def rna_to_protein(rna_string):

  codon_map = {
      'AUG': 'M', 'AUA': 'I', 'AUC': 'I', 'AUU': 'I',
      'ACG': 'T', 'ACA': 'T', 'ACU': 'T', 'ACC': 'T',
      'AAC': 'N', 'AAU': 'N',
      'AAG': 'K', 'AAA': 'K',
      'AGG': 'R', 'AGA': 'R',
      'AGC': 'S', 'AGU': 'S',
      'GUG': 'V', 'GUA': 'V', 'GUC': 'V', 'GUU': 'V',
      'GCG': 'A', 'GCA': 'A', 'GCC': 'A', 'GCU': 'A',
      'GAU': 'D', 'GAC': 'D',
      'GAG': 'E', 'GAA': 'E',
      'GGU': 'G', 'GGA': 'G', 'GGC': 'G', 'GGG': 'G',
      'UUU': 'F', 'UUC': 'F',
      'UUA': 'L', 'UUG': 'L',
      'UCU': 'S', 'UCA': 'S', 'UCC': 'S', 'UCG': 'S',
      'UAU': 'Y', 'UAC': 'Y',
      'UGU': 'C', 'UGC': 'C',
      'UGG': 'W',
      'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',
      'CCU': 'P', 'CCA': 'P', 'CCC': 'P', 'CCG': 'P',
      'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',
      'CAU': 'H', 'CAC': 'H',
      'CAG': 'Q', 'CAA': 'Q'
  }

  protein_string = ''
  start_index = rna_string.find('AUG')

  if start_index != -1:
    for i in range(start_index, len(rna_string), 3):
      codon = rna_string[i:i+3]
      if codon in ['UAG, UGA, UAA']:
        break
      else:
        protein_string += codon_map.get(codon, '')

  return protein_string
#

rna_to_protein('AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA')

"""SUBS

Problem
Given two strings s
 and t
, t
 is a substring of s
 if t
 is contained as a contiguous collection of symbols in s
 (as a result, t
 must be no longer than s
).

The position of a symbol in a string is the total number of symbols found to its left, including itself (e.g., the positions of all occurrences of 'U' in "AUGCUUCAGAAAGGUCUUACG" are 2, 5, 6, 15, 17, and 18). The symbol at position i
 of s
 is denoted by s[i]
.

A substring of s
 can be represented as s[j:k]
, where j
 and k
 represent the starting and ending positions of the substring in s
; for example, if s
 = "AUGCUUCAGAAAGGUCUUACG", then s[2:5]
 = "UGCU".

The location of a substring s[j:k]
 is its beginning position j
; note that t
 will have multiple locations in s
 if it occurs more than once as a substring of s
 (see the Sample below).

Given: Two DNA strings s
 and t
 (each of length at most 1 kbp).

Return: All locations of t
 as a substring of s.

Our function will intake two sequences, sequence 1 and sequence 2, we want to find all of the positions where sequence 2 appears in sequence 1. In order to do this we need to have some assumptions, the first is that sequence 2 has to be shorter in length than sequence 1.
"""

import re

def find_substring(sequence1, sequence2):
  if len(sequence2) >= len(sequence1):
    return "sequence 2 is longer than sequence 1"
  else:
    pattern = '(?={})'.format(sequence2)
    positions = [match.start()+ 1 for match in re.finditer(pattern, sequence1)]
  return positions

find_substring ('GATATATGCATATACTT', 'ATAT')

"""PRTM

Problem
In a weighted alphabet, every symbol is assigned a positive real number called a weight. A string formed from a weighted alphabet is called a weighted string, and its weight is equal to the sum of the weights of its symbols.

The standard weight assigned to each member of the 20-symbol amino acid alphabet is the monoisotopic mass of the corresponding amino acid.

Given: A protein string P
 of length at most 1000 aa.

Return: The total weight of P
. Consult the monoisotopic mass table.

The first thing we need to check is that the length of our protein string is no more than 1000 amino acids. After we check that, we will go through every amino acid in our string and match it with its mass and add it all up. In order to do that we will need a dictionary where we match amino acid to mass value.
"""

def protein_mass(protein_string):
  mass_dictionary = {
    'A' : '71.03711',  'C' : '103.00919', 'D' : '115.02694',
    'E' : '129.04259', 'F' : '147.06841', 'G' : '57.02146',
    'H' : '137.05891', 'I' : '113.08406', 'K' : '128.09496',
    'L' : '113.08406', 'M' : '131.04049', 'N' : '114.04293',
    'P' : '97.05276',  'Q' : '128.05858', 'R' : '156.10111',
    'S' : '87.03203',  'T' : '101.04768', 'V' : '99.06841',
    'W' : '186.07931', 'Y' : '163.06333'
}
  if len(protein_string) > 1000:
    return "protein string is too long"
  else:
    mass = 0
    for amino_acid in protein_string:
      amino_acid_mass= float(mass_dictionary[amino_acid])
      mass += amino_acid_mass
  return mass

protein_mass('SKADYEK')

"""REVP
Problem

Figure 2. Palindromic recognition site
A DNA string is a reverse palindrome if it is equal to its reverse complement. For instance, GCATGC is a reverse palindrome because its reverse complement is GCATGC. See Figure 2.

Given: A DNA string of length at most 1 kbp in FASTA format.

Return: The position and length of every reverse palindrome in the string having length between 4 and 12. You may return these pairs in any order
"""

#First, we need to ensure our DNA string is at most 1 kbp in FASTA format. Then, we must make sure all of the palindromes in the string have a length between 4 and 12. We also must iterate through to find a palindrome length between these two values.

dna_dict = {'A':'T', 'T':'A', 'G':'C', 'C':'G'}
def reverse_complement(dna):
  reverse= dna[::-1]
  reverse_complement = ''
  for nucleotide in reverse:
    reverse_complement += dna_dict[nucleotide]
  return reverse_complement

def reverse_palindrome(dna_string):
  results = []
  n=len(dna_string)
  for length in range(4,13):
    for start in range(0, n - length+1):

      substring = dna_string[start:start+length]
      if substring == reverse_complement(substring):
        results.append((start+1, length))
  return results

reverse_palindrome ('GATGGAACTTGACTACGTAAATT')

"""TRAN

Problem
For DNA strings s1
 and s2
 having the same length, their transition/transversion ratio R(s1,s2)
 is the ratio of the total number of transitions to the total number of transversions, where symbol substitutions are inferred from mismatched corresponding symbols as when calculating Hamming distance (see “Counting Point Mutations”).

Given: Two DNA strings s1
 and s2
 of equal length (at most 1 kbp).

Return: The transition/transversion ratio R(s1,s2).
"""

#For this problem, we need to start by creating a dictionary of all of the possible tranversion and transition events for each nucleotide. We need to make a function with two DNA sequences as an input and we want to return a ratio of number of transition events divided by transversion events. The main assumption that we need to check for is that string 1 and string 2 are the same length.

def ttotratio(sequence1,sequence2):

  transitions_count=0
  tranversions_count=0

  purines = {'A','G'}
  pyrimidines = {'C','T'}

  for i in range(len(sequence1)):
    n1 = sequence1[i]
    n2 = sequence2[i]

    if n1 != n2:
      if (n1 in purines and n2 in purines) or (n1 in pyrimidines and n2 in pyrimidines):
        transitions_count += 1

      elif (n1 in purines and n2 in pyrimidines) or (n1 in pyrimidines and n2 in purines):
        tranversions_count += 1

  if tranversions_count==0:
    return "No transversions"
  else:
    ratio= transitions_count/tranversions_count
  return ratio

ttotratio('GCAACGCACAACGAAAACCCTTAGGGACTGGATTATTTCGTGATCGTTGTAGTTATTGGAAGTACGGGCATCAACCCAGTT', 'TTATCTGACAAAGAAAGCCGTCAACGGCTGGATAATTTCGCGATCGTGCTGGTTACTGGCGGTACGAGTGTTCCTTTGGGT')